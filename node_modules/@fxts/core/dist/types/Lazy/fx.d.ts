import type Cast from "../types/Cast";
import type { DeepFlat } from "../types/DeepFlat";
import type IterableInfer from "../types/IterableInfer";
import type Key from "../types/Key";
import type { SyncReducer } from "../types/Reducer";
declare class FxAsyncIterable<A> {
    private asyncIterable;
    constructor(asyncIterable: AsyncIterable<A>);
    [Symbol.asyncIterator](): AsyncIterator<A, any, undefined>;
    /**
     * Returns AsyncIterable of values by running each applying `f`.
     *
     * see {@link https://fxts.dev/docs/map | map}
     */
    map<B>(f: (a: A) => B): FxAsyncIterable<import("../types/Awaited").default<B>>;
    /**
     * Returns flattened AsyncIterable of values by running each element
     * flattening the mapped results.
     *
     * see {@link https://fxts.dev/docs/flatMap | flatMap}
     */
    flatMap<B>(f: (a: A) => B): FxAsyncIterable<DeepFlat<import("../types/Awaited").default<B>, 1>>;
    /**
     * Returns flattened AsyncIterable.
     * If first argument is number, more perform flatten
     *
     * @example
     * ```
     * await fx([[1],[[2]]])
     *   .toAsync()
     *   .flat(2).toArray(); // [1,2]
     * ```
     *
     * see {@link https://fxts.dev/docs/flat | flat}
     */
    flat<T extends number = 1>(depth?: T): FxAsyncIterable<DeepFlat<A, T>>;
    /**
     * Return AsyncIterable of all elements `f` returns truthy for
     *
     * see {@link https://fxts.dev/docs/filter | filter}
     */
    filter(f: (a: A) => unknown): FxAsyncIterable<A>;
    /**
     * The opposite of filter method
     * AsyncIterable of all elements `f` returns falsy for
     *
     * see {@link https://fxts.dev/docs/reject | reject}
     */
    reject(f: (a: A) => unknown): FxAsyncIterable<A>;
    /**
     * Returns AsyncIterable that taken the first argument `l` values from asyncIterable
     *
     * see {@link https://fxts.dev/docs/take | take}
     */
    take(n: number): FxAsyncIterable<A>;
    /**
     * Returns AsyncIterable that taken values until truthy when given `f` is applied.
     *
     * see {@link https://fxts.dev/docs/takeUntil | takeUntil}
     */
    takeUntil(f: (a: A) => unknown): FxAsyncIterable<A>;
    /**
     * Returns AsyncIterable that taken values as long as each value satisfies the give `f`.
     *
     * see {@link https://fxts.dev/docs/takeWhile | takeWhile}
     */
    takeWhile(f: (a: A) => unknown): FxAsyncIterable<A>;
    /**
     * Iterate over an input list,
     * calling a provided `f` for each element in the AsyncIterable.
     *
     * see {@link https://fxts.dev/docs/peek | peek}
     */
    peek(f: (a: A) => unknown): FxAsyncIterable<A>;
    /**
     * Returns all but the first `length` elements of the given asyncIterable.
     *
     * see {@link https://fxts.dev/docs/drop | drop}
     */
    drop(length: number): FxAsyncIterable<A>;
    /**
     * Returns AsyncIterable of the given elements from startIndex(inclusive) to endIndex(exclusive).
     *
     * see {@link https://fxts.dev/docs/slice | slice}
     */
    slice(start: number, end?: number): FxAsyncIterable<A>;
    /**
     *
     * `chain` allows you to use functions that are not provided in method chaining.
     * The functions available for the `chain` argument return an iterable.
     *
     * @example
     * ```
     * await fx(toAsync(range(1, 4)))
     *   .chain(append(4))
     *   .chain(append(5))
     *   .toArray(); // [1, 2, 3, 4, 5]
     * ```
     */
    chain<B>(f: (asyncIterable: AsyncIterable<A>) => AsyncIterable<Awaited<B>>): FxAsyncIterable<B>;
    /**
     * Concurrent is used to balance the load of multiple asynchronous requests.
     * The first argument receives a number that controls the number of loads, and the second argument is an AsyncIterable.
     *
     * see {@link https://fxts.dev/docs/concurrent | concurrent}
     */
    concurrent(length: number): FxAsyncIterable<A>;
    consume(): Promise<void>;
    /**
     * Splits AsyncIterable into sets, grouped by the result of running each value through `f`.
     *
     * see {@link https://fxts.dev/docs/groupBy | groupBy}
     */
    groupBy(f: (a: A) => Key): Promise<{
        [x: string]: A[];
        [x: number]: A[];
        [x: symbol]: A[];
    }>;
    /**
     * Given `f` that generates a key,
     * turns a list of objects into an object indexing the objects by the given key.
     * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.
     *
     * see {@link https://fxts.dev/docs/indexBy | indexBy}
     */
    indexBy(f: (a: A) => Key): Promise<{
        [x: string]: A;
        [x: number]: A;
        [x: symbol]: A;
    }>;
    /**
     * Returns true if any of the values in AsyncIterable pass `f` truth test
     *
     * see {@link https://fxts.dev/docs/some | some}
     */
    some(f: (a: A) => unknown): Promise<boolean>;
    /**
     * Returns true if all of the values in AsyncIterable pass the `f` truth test.
     *
     * see {@link https://fxts.dev/docs/every | every}
     */
    every(f: (a: A) => unknown): Promise<boolean>;
    /**
     * Returns all elements in the given iterable into a string separated by separator.
     *
     * see {@link https://fxts.dev/docs/join | join}
     */
    join(sep: string): Promise<string>;
    /**
     * Looks through each value in AsyncIterable, returning the first one that passes a truth test `f`,
     * or `undefined` if no value passes the test.
     *
     * see {@link https://fxts.dev/docs/find | find}
     */
    find(f: (a: A) => unknown): Promise<A | undefined>;
    /**
     * Returns the index of the first element of AsyncIterable which matches f, or -1 if no element matches.
     *
     * see {@link https://fxts.dev/docs/findIndex | findIndex}
     */
    findIndex(f: (a: A) => unknown): Promise<number>;
    /**
     * Also known as foldl, this method boils down a list of values into a single value.
     *
     * see {@link https://fxts.dev/docs/reduce | reduce}
     */
    reduce<B>(f: SyncReducer<Cast<A, B>, A>, seed?: B): Promise<Cast<A, B>>;
    /**
     * Iterates over AsyncIterable, applying each in turn to `f`.
     *
     * see {@link https://fxts.dev/docs/each | each}
     */
    each(f: (a: A) => unknown): Promise<void>;
    /**
     * Takes item from AsyncIterable and returns an array.
     *
     * see {@link https://fxts.dev/docs/toArray | toArray}
     */
    toArray(): Promise<Array<Awaited<A>>>;
}
export declare class FxIterable<A> {
    private iterable;
    constructor(iterable: Iterable<A>);
    [Symbol.iterator](): Iterator<A, any, undefined>;
    /**
     * Returns Iterable of values by running each applying `f`.
     *
     * see {@link https://fxts.dev/docs/map | map}
     */
    map<B>(f: (a: A) => B): FxIterable<B>;
    /**
     * Returns flattened Iterable of values by running each element
     * flattening the mapped results.
     *
     * see {@link https://fxts.dev/docs/flatMap | flatMap}
     */
    flatMap<B>(f: (a: A) => B): FxIterable<import("../types/DeepFlat").DeepFlatSync<B, 1>>;
    /**
     * Returns flattened Iterable.
     * If first argument is number, more perform flatten
     *
     * @example
     * `fx([[1],[[2]]]).flat(2).toArray(); // [1,2]`
     *
     * see {@link https://fxts.dev/docs/flat | flat}
     */
    flat<T extends number = 1>(depth?: T): FxIterable<DeepFlat<A, T>>;
    /**
     * Return Iterable of all elements `f` returns truthy for
     *
     * see {@link https://fxts.dev/docs/filter | filter}
     */
    filter(f: (a: A) => unknown): FxIterable<A>;
    /**
     * The opposite of filter method
     * Iterable of all elements `f` returns falsy for
     *
     * see {@link https://fxts.dev/docs/reject | reject}
     */
    reject(f: (a: A) => unknown): FxIterable<A>;
    /**
     * Returns Iterable that taken the first argument `l` values from iterable
     *
     * see {@link https://fxts.dev/docs/take | take}
     */
    take(n: number): FxIterable<A>;
    /**
     * Returns Iterable that taken values until truthy when given `f` is applied.
     *
     * see {@link https://fxts.dev/docs/takeUntil | takeUntil}
     */
    takeUntil(f: (a: A) => unknown): FxIterable<A>;
    /**
     * Returns Iterable that taken values as long as each value satisfies the give `f`.
     *
     * see {@link https://fxts.dev/docs/takeWhile | takeWhile}
     */
    takeWhile(f: (a: A) => unknown): FxIterable<A>;
    /**
     * Iterate over an input list,
     * calling a provided `f` for each element in the Iterable.
     *
     * see {@link https://fxts.dev/docs/peek | peek}
     */
    peek(f: (a: A) => unknown): FxIterable<A>;
    /**
     * Returns all but the first `length` elements of the given iterable.
     *
     * see {@link https://fxts.dev/docs/drop | drop}
     */
    drop(length: number): FxIterable<A>;
    /**
     * Returns Iterable of the given elements from startIndex(inclusive) to endIndex(exclusive).
     *
     * see {@link https://fxts.dev/docs/slice | slice}
     */
    slice(start: number, end?: number): FxIterable<A>;
    /**
     *
     * `chain` allows you to use functions that are not provided in method chaining.
     * The functions available for the `chain` argument return an asyncIterable.
     *
     * @example
     * ```
     * fx(range(1, 4))
     *   .chain(append(4))
     *   .chain(append(5))
     *   .toArray(); // [1, 2, 3, 4, 5]
     * ```
     */
    chain<B>(f: (iterable: Iterable<A>) => Iterable<B>): FxIterable<B>;
    /**
     * Returns AsyncIterable, `toAsync` used when you want to handle Promise values inside Iterable.
     *
     * see {@link https://fxts.dev/docs/toAsync | toAsync}
     */
    toAsync(): FxAsyncIterable<A>;
    /**
     * Splits Iterable into sets, grouped by the result of running each value through `f`.
     *
     * see {@link https://fxts.dev/docs/groupBy | groupBy}
     */
    groupBy(f: (a: A) => Key): {
        [x: string]: A[];
        [x: number]: A[];
        [x: symbol]: A[];
    };
    /**
     * Given `f` that generates a key,
     * turns a list of objects into an object indexing the objects by the given key.
     * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.
     *
     * see {@link https://fxts.dev/docs/indexBy | indexBy}
     */
    indexBy(f: (a: A) => Key): {
        [x: string]: A;
        [x: number]: A;
        [x: symbol]: A;
    };
    /**
     * Returns true if any of the values in AsyncIterable pass `f` truth test
     *
     * see {@link https://fxts.dev/docs/some | some}
     */
    some(f: (a: A) => unknown): boolean;
    /**
     * Returns true if all of the values in AsyncIterable pass the `f` truth test.
     *
     * see {@link https://fxts.dev/docs/every | every}
     */
    every(f: (a: A) => unknown): boolean;
    /**
     * Returns all elements in the given iterable into a string separated by separator.
     *
     * see {@link https://fxts.dev/docs/join | join}
     */
    join(sep: string): string;
    /**
     * Looks through each value in AsyncIterable, returning the first one that passes a truth test `f`,
     * or `undefined` if no value passes the test.
     *
     * see {@link https://fxts.dev/docs/find | find}
     */
    find(f: (a: A) => unknown): A | undefined;
    /**
     * Returns the index of the first element of AsyncIterable which matches f, or -1 if no element matches.
     *
     * see {@link https://fxts.dev/docs/findIndex | findIndex}
     */
    findIndex(f: (a: A) => unknown): number;
    /**
     * Also known as foldl, this method boils down a list of values into a single value.
     *
     * see {@link https://fxts.dev/docs/reduce | reduce}
     */
    reduce<B>(f: SyncReducer<Cast<A, B>, A>, seed?: B): Cast<A, B>;
    /**
     * Iterates over Iterable, applying each in turn to `f`.
     *
     * see {@link https://fxts.dev/docs/each | each}
     */
    each(f: (a: A) => unknown): void;
    /**
     * Takes item from Iterable and returns an array.
     *
     * see {@link https://fxts.dev/docs/toArray | toArray}
     */
    toArray(): Array<A>;
    toIterator(): Array<A>;
}
/**
 * `fx` allows functions provided by existing `fxts` to be used in a method chaining.
 *  Not all functions are provided as methods and can be connected through `chain` if necessary.
 *
 *  see {@link https://fxts.dev/docs/method-chaining | guide}
 *
 * @example
 * ```ts
 * const syncArr1 = fx([1, 2, 3, 4])
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 *
 * // If you want to use another function that is not provided for the method, use `chain`.
 * const syncArr2 = fx([1, 2, 3, 4])
 *   .chain(append(5))
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14, 15]
 *
 * const asyncArr1 = await fx([1, 2, 3, 4])
 *   .toAsync()
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 *
 * const asyncArr2 = await fx(toAsync([1, 2, 3, 4]))
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 * ```
 */
declare function fx<T extends Iterable<unknown> | AsyncIterable<unknown>>(a: T): T extends Iterable<unknown> ? FxIterable<IterableInfer<T>> : FxAsyncIterable<IterableInfer<T>>;
export default fx;
//# sourceMappingURL=fx.d.ts.map