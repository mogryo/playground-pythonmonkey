{"version":3,"file":"reduce.js","sourceRoot":"","sources":["../../src/reduce.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,mBAAmB,CAAC;AAChE,OAAO,KAAK,MAAM,SAAS,CAAC;AAM5B,SAAS,IAAI,CACX,CAAsB,EACtB,GAAQ,EACR,QAAqB;IAErB,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE;QACxB,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;KACjB;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED,KAAK,UAAU,KAAK,CAClB,CAAsB,EACtB,GAAiB,EACjB,QAA0B;IAE1B,IAAI,KAAK,EAAE,MAAM,CAAC,IAAI,QAAQ,EAAE;QAC9B,mCAAmC;QACnC,GAAG,GAAG,MAAM,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,GAAU,EAAE,CAAC,CAAC,CAAC,CAAC;KACnD;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAwHD,SAAS,MAAM,CACb,CAAqC,EACrC,IAAyE,EACzE,QAAuE;IAEvE,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,IAAI,IAAI,KAAK,SAAS,EAAE;YACtB,OAAO,CAAC,QAAW,EAAE,EAAE,CACrB,MAAM,CAAC,CAAC,EAAE,QAAe,CAA4B,CAAC;SACzD;QAED,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;YACpB,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;YACzC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;YACxC,IAAI,IAAI,EAAE;gBACR,MAAM,IAAI,SAAS,CAAC,kDAAkD,CAAC,CAAC;aACzE;YACD,OAAO,IAAI,CAAC,CAAC,EAAE,KAAY,EAAE;gBAC3B,CAAC,MAAM,CAAC,QAAQ,CAAC;oBACf,OAAO,QAAQ,CAAC;gBAClB,CAAC;aACF,CAAC,CAAC;SACJ;QAED,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;YACzB,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;YAC9C,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE;gBAC9C,IAAI,IAAI,EAAE;oBACR,MAAM,IAAI,SAAS,CACjB,kDAAkD,CACnD,CAAC;iBACH;gBAED,OAAO,KAAK,CAAC,CAAC,EAAE,KAAqB,EAAE;oBACrC,CAAC,MAAM,CAAC,aAAa,CAAC;wBACpB,OAAO,QAAQ,CAAC;oBAClB,CAAC;iBACF,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;SACJ;QAED,MAAM,IAAI,SAAS,CACjB,yFAAyF,CAC1F,CAAC;KACH;IAED,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,IAAI,CAAC,CAAC,EAAE,IAAW,EAAE,QAAQ,CAAC,CAAC;KACvC;IAED,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC,OAAO,CAAC,IAAW,CAAC,EAAE,QAAQ,CAAC,CAAC;KACzD;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,MAAM,CAAC","sourcesContent":["import { isAsyncIterable, isIterable } from \"./_internal/utils\";\nimport pipe1 from \"./pipe1\";\nimport type Arrow from \"./types/Arrow\";\nimport type IterableInfer from \"./types/IterableInfer\";\nimport type { AsyncReducer, SyncReducer } from \"./types/Reducer\";\nimport type ReturnValueType from \"./types/ReturnValueType\";\n\nfunction sync<T, Acc>(\n  f: SyncReducer<Acc, T>,\n  acc: Acc,\n  iterable: Iterable<T>,\n): Acc {\n  for (const a of iterable) {\n    acc = f(acc, a);\n  }\n  return acc;\n}\n\nasync function async<T, Acc>(\n  f: SyncReducer<Acc, T>,\n  acc: Promise<Acc>,\n  iterable: AsyncIterable<T>,\n) {\n  for await (const a of iterable) {\n    // becauseof using es5, use `await`\n    acc = await pipe1(acc, (acc) => f(acc as Acc, a));\n  }\n  return acc;\n}\n\n/**\n * Also known as foldl, this method boils down a list of values into a single value.\n *\n * @example\n * You can reduce values into homogeneous type.\n *\n * ```ts\n * const sum = (a:number, b:number) => a + b;\n *\n * // with implicit seed with first element\n * reduce(sum, [1, 2, 3, 4]); // 10\n *\n * // with explicit seed\n * reduce(sum, 0, [1, 2, 3, 4]); // 10\n * ```\n *\n * You can reduce values into heterogeneous type.\n *\n * ```ts\n * // reduce { id: number; score: number; } to number\n * reduce((acc, value) => acc + value.score, 0, [\n *  { id: 0, score: 1 },\n *  { id: 5, score: 2 },\n *  { id: 9, score: 3 },\n *  { id: 3, score: 4 }\n * ])\n * ```\n *\n * Omitting iterable will returns function, useful when using with pipe.\n *\n * ```ts\n * pipe(\n *  [1, 2, 3, 4],\n *  map(a => a + 10),\n *  filter(a => a % 2 === 0),\n *  reduce(sum),\n * ); // 26\n * ```\n *\n * For backward compatibility, `reduce` can support partial lazy form.\n * You may want to use `reduceLazy` to use `seed`.\n *\n * ```ts\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4]),\n *  map((a) => a + 10),\n *  filter(a => a % 2 === 0),\n *  reduce(sum),\n * ); // 26\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4]),\n *  toAsync,\n *  map(async (a) => a + 10),\n *  filter(a => a % 2 === 0),\n *  reduce(sum),\n * ); // 26\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3), Promise.resolve(4)],\n *  toAsync,\n *  map(a => a + 10),\n *  filter(a => a % 2 === 0),\n *  reduce(sum),\n * ); // 26\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-reduce-tf56j  | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/map | map}, {@link https://fxts.dev/docs/filter | filter}\n *\n * @typeParam T - Type of values in `iterable` which would be consummed.\n * @typeParam Acc - Type of `acc` which is the type of accumulative value\n */\n\nfunction reduce<T extends readonly [], Acc>(\n  f: Arrow,\n  seed: Acc,\n  iterable: T,\n): Acc;\n\nfunction reduce<T>(f: SyncReducer<T, T>, iterable: Iterable<T>): T;\n\nfunction reduce<T, Acc>(f: SyncReducer<Acc, T>, iterable: Iterable<T>): Acc;\n\nfunction reduce<T, Acc>(\n  f: SyncReducer<Acc, T>,\n  seed: Acc,\n  iterable: Iterable<T>,\n): Acc;\n\nfunction reduce<T>(\n  f: SyncReducer<T, T>,\n  iterable: AsyncIterable<T>,\n): Promise<T>;\n\nfunction reduce<T, Acc>(\n  f: AsyncReducer<Acc, T>,\n  seed: Acc | Promise<Acc>,\n  iterable: AsyncIterable<T>,\n): Promise<Acc>;\n\nfunction reduce<T, Acc>(\n  f: AsyncReducer<Acc, T>,\n  iterable: AsyncIterable<T>,\n): Promise<Acc>;\n\nfunction reduce<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: AsyncReducer<IterableInfer<T>, IterableInfer<T>>,\n): (iterable: T) => ReturnValueType<T>;\n\nfunction reduce<T extends Iterable<unknown> | AsyncIterable<unknown>, Acc>(\n  f: AsyncReducer<Acc, IterableInfer<T>>,\n): (iterable: T) => ReturnValueType<T, Acc>;\n\nfunction reduce<T extends Iterable<unknown> | AsyncIterable<unknown>, Acc>(\n  f: SyncReducer<Acc, IterableInfer<T>>,\n  seed?: Acc | Iterable<IterableInfer<T>> | AsyncIterable<IterableInfer<T>>,\n  iterable?: Iterable<IterableInfer<T>> | AsyncIterable<IterableInfer<T>>,\n): Acc | Promise<Acc> | ((iterable: T) => ReturnValueType<T, Acc>) {\n  if (iterable === undefined) {\n    if (seed === undefined) {\n      return (iterable: T) =>\n        reduce(f, iterable as any) as ReturnValueType<T, Acc>;\n    }\n\n    if (isIterable(seed)) {\n      const iterator = seed[Symbol.iterator]();\n      const { done, value } = iterator.next();\n      if (done) {\n        throw new TypeError(\"'reduce' of empty iterable with no initial value\");\n      }\n      return sync(f, value as Acc, {\n        [Symbol.iterator]() {\n          return iterator;\n        },\n      });\n    }\n\n    if (isAsyncIterable(seed)) {\n      const iterator = seed[Symbol.asyncIterator]();\n      return iterator.next().then(({ done, value }) => {\n        if (done) {\n          throw new TypeError(\n            \"'reduce' of empty iterable with no initial value\",\n          );\n        }\n\n        return async(f, value as Promise<Acc>, {\n          [Symbol.asyncIterator]() {\n            return iterator;\n          },\n        });\n      });\n    }\n\n    throw new TypeError(\n      \"'iterable' must be type of Iterable or AsyncIterable. Are you looking for 'reduceLazy'?\",\n    );\n  }\n\n  if (isIterable(iterable)) {\n    return sync(f, seed as Acc, iterable);\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return async(f, Promise.resolve(seed as Acc), iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default reduce;\n"]}