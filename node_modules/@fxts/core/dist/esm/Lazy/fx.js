import { isAsyncIterable, isIterable } from "../_internal/utils.js";
import consume from "../consume.js";
import each from "../each.js";
import every from "../every.js";
import find from "../find.js";
import findIndex from "../findIndex.js";
import groupBy from "../groupBy.js";
import indexBy from "../indexBy.js";
import isUndefined from "../isUndefined.js";
import join from "../join.js";
import reduce from "../reduce.js";
import some from "../some.js";
import concurrent from "./concurrent.js";
import drop from "./drop.js";
import filter from "./filter.js";
import flat from "./flat.js";
import flatMap from "./flatMap.js";
import map from "./map.js";
import peek from "./peek.js";
import reject from "./reject.js";
import slice from "./slice.js";
import take from "./take.js";
import takeUntil from "./takeUntil.js";
import takeWhile from "./takeWhile.js";
import toAsync from "./toAsync.js";
class FxAsyncIterable {
    constructor(asyncIterable) {
        this.asyncIterable = asyncIterable;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterable[Symbol.asyncIterator]();
    }
    /**
     * Returns AsyncIterable of values by running each applying `f`.
     *
     * see {@link https://fxts.dev/docs/map | map}
     */
    map(f) {
        return new FxAsyncIterable(map(f, this.asyncIterable));
    }
    /**
     * Returns flattened AsyncIterable of values by running each element
     * flattening the mapped results.
     *
     * see {@link https://fxts.dev/docs/flatMap | flatMap}
     */
    flatMap(f) {
        return new FxAsyncIterable(flatMap(f, this.asyncIterable));
    }
    /**
     * Returns flattened AsyncIterable.
     * If first argument is number, more perform flatten
     *
     * @example
     * ```
     * await fx([[1],[[2]]])
     *   .toAsync()
     *   .flat(2).toArray(); // [1,2]
     * ```
     *
     * see {@link https://fxts.dev/docs/flat | flat}
     */
    flat(depth) {
        return new FxAsyncIterable(flat(this.asyncIterable, depth));
    }
    /**
     * Return AsyncIterable of all elements `f` returns truthy for
     *
     * see {@link https://fxts.dev/docs/filter | filter}
     */
    filter(f) {
        return new FxAsyncIterable(filter(f, this.asyncIterable));
    }
    /**
     * The opposite of filter method
     * AsyncIterable of all elements `f` returns falsy for
     *
     * see {@link https://fxts.dev/docs/reject | reject}
     */
    reject(f) {
        return new FxAsyncIterable(reject(f, this.asyncIterable));
    }
    /**
     * Returns AsyncIterable that taken the first argument `l` values from asyncIterable
     *
     * see {@link https://fxts.dev/docs/take | take}
     */
    take(n) {
        return new FxAsyncIterable(take(n, this.asyncIterable));
    }
    /**
     * Returns AsyncIterable that taken values until truthy when given `f` is applied.
     *
     * see {@link https://fxts.dev/docs/takeUntil | takeUntil}
     */
    takeUntil(f) {
        return new FxAsyncIterable(takeUntil(f, this.asyncIterable));
    }
    /**
     * Returns AsyncIterable that taken values as long as each value satisfies the give `f`.
     *
     * see {@link https://fxts.dev/docs/takeWhile | takeWhile}
     */
    takeWhile(f) {
        return new FxAsyncIterable(takeWhile(f, this.asyncIterable));
    }
    /**
     * Iterate over an input list,
     * calling a provided `f` for each element in the AsyncIterable.
     *
     * see {@link https://fxts.dev/docs/peek | peek}
     */
    peek(f) {
        return new FxAsyncIterable(peek(f, this.asyncIterable));
    }
    /**
     * Returns all but the first `length` elements of the given asyncIterable.
     *
     * see {@link https://fxts.dev/docs/drop | drop}
     */
    drop(length) {
        return new FxAsyncIterable(drop(length, this.asyncIterable));
    }
    /**
     * Returns AsyncIterable of the given elements from startIndex(inclusive) to endIndex(exclusive).
     *
     * see {@link https://fxts.dev/docs/slice | slice}
     */
    slice(start, end) {
        return isUndefined(end)
            ? new FxAsyncIterable(slice(start, this.asyncIterable))
            : new FxAsyncIterable(slice(start, end, this.asyncIterable));
    }
    /**
     *
     * `chain` allows you to use functions that are not provided in method chaining.
     * The functions available for the `chain` argument return an iterable.
     *
     * @example
     * ```
     * await fx(toAsync(range(1, 4)))
     *   .chain(append(4))
     *   .chain(append(5))
     *   .toArray(); // [1, 2, 3, 4, 5]
     * ```
     */
    chain(f) {
        return new FxAsyncIterable(f(this.asyncIterable));
    }
    /**
     * Concurrent is used to balance the load of multiple asynchronous requests.
     * The first argument receives a number that controls the number of loads, and the second argument is an AsyncIterable.
     *
     * see {@link https://fxts.dev/docs/concurrent | concurrent}
     */
    concurrent(length) {
        return new FxAsyncIterable(concurrent(length, this.asyncIterable));
    }
    async consume() {
        return consume(this.asyncIterable);
    }
    /**
     * Splits AsyncIterable into sets, grouped by the result of running each value through `f`.
     *
     * see {@link https://fxts.dev/docs/groupBy | groupBy}
     */
    async groupBy(f) {
        return groupBy(f, this.asyncIterable);
    }
    /**
     * Given `f` that generates a key,
     * turns a list of objects into an object indexing the objects by the given key.
     * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.
     *
     * see {@link https://fxts.dev/docs/indexBy | indexBy}
     */
    async indexBy(f) {
        return indexBy(f, this.asyncIterable);
    }
    /**
     * Returns true if any of the values in AsyncIterable pass `f` truth test
     *
     * see {@link https://fxts.dev/docs/some | some}
     */
    async some(f) {
        return some(f, this.asyncIterable);
    }
    /**
     * Returns true if all of the values in AsyncIterable pass the `f` truth test.
     *
     * see {@link https://fxts.dev/docs/every | every}
     */
    async every(f) {
        return every(f, this.asyncIterable);
    }
    /**
     * Returns all elements in the given iterable into a string separated by separator.
     *
     * see {@link https://fxts.dev/docs/join | join}
     */
    async join(sep) {
        return join(sep, this.asyncIterable);
    }
    /**
     * Looks through each value in AsyncIterable, returning the first one that passes a truth test `f`,
     * or `undefined` if no value passes the test.
     *
     * see {@link https://fxts.dev/docs/find | find}
     */
    async find(f) {
        return find(f, this.asyncIterable);
    }
    /**
     * Returns the index of the first element of AsyncIterable which matches f, or -1 if no element matches.
     *
     * see {@link https://fxts.dev/docs/findIndex | findIndex}
     */
    async findIndex(f) {
        return findIndex(f, this.asyncIterable);
    }
    /**
     * Also known as foldl, this method boils down a list of values into a single value.
     *
     * see {@link https://fxts.dev/docs/reduce | reduce}
     */
    async reduce(f, seed) {
        return isUndefined(seed)
            ? reduce(f, this.asyncIterable)
            : reduce(f, seed, this.asyncIterable);
    }
    /**
     * Iterates over AsyncIterable, applying each in turn to `f`.
     *
     * see {@link https://fxts.dev/docs/each | each}
     */
    async each(f) {
        return each(f, this.asyncIterable);
    }
    /**
     * Takes item from AsyncIterable and returns an array.
     *
     * see {@link https://fxts.dev/docs/toArray | toArray}
     */
    async toArray() {
        const array = [];
        for await (const a of this.asyncIterable) {
            array.push(a);
        }
        return array;
    }
}
export class FxIterable {
    constructor(iterable) {
        this.iterable = iterable;
    }
    [Symbol.iterator]() {
        return this.iterable[Symbol.iterator]();
    }
    /**
     * Returns Iterable of values by running each applying `f`.
     *
     * see {@link https://fxts.dev/docs/map | map}
     */
    map(f) {
        return new FxIterable(map(f, this.iterable));
    }
    /**
     * Returns flattened Iterable of values by running each element
     * flattening the mapped results.
     *
     * see {@link https://fxts.dev/docs/flatMap | flatMap}
     */
    flatMap(f) {
        return new FxIterable(flatMap(f, this.iterable));
    }
    /**
     * Returns flattened Iterable.
     * If first argument is number, more perform flatten
     *
     * @example
     * `fx([[1],[[2]]]).flat(2).toArray(); // [1,2]`
     *
     * see {@link https://fxts.dev/docs/flat | flat}
     */
    flat(depth) {
        const res = flat(this.iterable, depth);
        return new FxIterable(res);
    }
    /**
     * Return Iterable of all elements `f` returns truthy for
     *
     * see {@link https://fxts.dev/docs/filter | filter}
     */
    filter(f) {
        return new FxIterable(filter(f, this.iterable));
    }
    /**
     * The opposite of filter method
     * Iterable of all elements `f` returns falsy for
     *
     * see {@link https://fxts.dev/docs/reject | reject}
     */
    reject(f) {
        return new FxIterable(reject(f, this.iterable));
    }
    /**
     * Returns Iterable that taken the first argument `l` values from iterable
     *
     * see {@link https://fxts.dev/docs/take | take}
     */
    take(n) {
        return new FxIterable(take(n, this.iterable));
    }
    /**
     * Returns Iterable that taken values until truthy when given `f` is applied.
     *
     * see {@link https://fxts.dev/docs/takeUntil | takeUntil}
     */
    takeUntil(f) {
        return new FxIterable(takeUntil(f, this.iterable));
    }
    /**
     * Returns Iterable that taken values as long as each value satisfies the give `f`.
     *
     * see {@link https://fxts.dev/docs/takeWhile | takeWhile}
     */
    takeWhile(f) {
        return new FxIterable(takeWhile(f, this.iterable));
    }
    /**
     * Iterate over an input list,
     * calling a provided `f` for each element in the Iterable.
     *
     * see {@link https://fxts.dev/docs/peek | peek}
     */
    peek(f) {
        return new FxIterable(peek(f, this.iterable));
    }
    /**
     * Returns all but the first `length` elements of the given iterable.
     *
     * see {@link https://fxts.dev/docs/drop | drop}
     */
    drop(length) {
        return new FxIterable(drop(length, this.iterable));
    }
    /**
     * Returns Iterable of the given elements from startIndex(inclusive) to endIndex(exclusive).
     *
     * see {@link https://fxts.dev/docs/slice | slice}
     */
    slice(start, end) {
        return isUndefined(end)
            ? new FxIterable(slice(start, this.iterable))
            : new FxIterable(slice(start, end, this.iterable));
    }
    /**
     *
     * `chain` allows you to use functions that are not provided in method chaining.
     * The functions available for the `chain` argument return an asyncIterable.
     *
     * @example
     * ```
     * fx(range(1, 4))
     *   .chain(append(4))
     *   .chain(append(5))
     *   .toArray(); // [1, 2, 3, 4, 5]
     * ```
     */
    chain(f) {
        return new FxIterable(f(this.iterable));
    }
    /**
     * Returns AsyncIterable, `toAsync` used when you want to handle Promise values inside Iterable.
     *
     * see {@link https://fxts.dev/docs/toAsync | toAsync}
     */
    toAsync() {
        return new FxAsyncIterable(toAsync(this.iterable));
    }
    /**
     * Splits Iterable into sets, grouped by the result of running each value through `f`.
     *
     * see {@link https://fxts.dev/docs/groupBy | groupBy}
     */
    groupBy(f) {
        return groupBy(f, this.iterable);
    }
    /**
     * Given `f` that generates a key,
     * turns a list of objects into an object indexing the objects by the given key.
     * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.
     *
     * see {@link https://fxts.dev/docs/indexBy | indexBy}
     */
    indexBy(f) {
        return indexBy(f, this.iterable);
    }
    /**
     * Returns true if any of the values in AsyncIterable pass `f` truth test
     *
     * see {@link https://fxts.dev/docs/some | some}
     */
    some(f) {
        return some(f, this.iterable);
    }
    /**
     * Returns true if all of the values in AsyncIterable pass the `f` truth test.
     *
     * see {@link https://fxts.dev/docs/every | every}
     */
    every(f) {
        return every(f, this.iterable);
    }
    /**
     * Returns all elements in the given iterable into a string separated by separator.
     *
     * see {@link https://fxts.dev/docs/join | join}
     */
    join(sep) {
        return join(sep, this.iterable);
    }
    /**
     * Looks through each value in AsyncIterable, returning the first one that passes a truth test `f`,
     * or `undefined` if no value passes the test.
     *
     * see {@link https://fxts.dev/docs/find | find}
     */
    find(f) {
        return find(f, this.iterable);
    }
    /**
     * Returns the index of the first element of AsyncIterable which matches f, or -1 if no element matches.
     *
     * see {@link https://fxts.dev/docs/findIndex | findIndex}
     */
    findIndex(f) {
        return findIndex(f, this.iterable);
    }
    /**
     * Also known as foldl, this method boils down a list of values into a single value.
     *
     * see {@link https://fxts.dev/docs/reduce | reduce}
     */
    reduce(f, seed) {
        return isUndefined(seed)
            ? reduce(f, this.iterable)
            : reduce(f, seed, this.iterable);
    }
    /**
     * Iterates over Iterable, applying each in turn to `f`.
     *
     * see {@link https://fxts.dev/docs/each | each}
     */
    each(f) {
        return each(f, this.iterable);
    }
    /**
     * Takes item from Iterable and returns an array.
     *
     * see {@link https://fxts.dev/docs/toArray | toArray}
     */
    toArray() {
        return Array.from(this.iterable);
    }
    toIterator() {
        return Array.from(this.iterable);
    }
}
/**
 * `fx` allows functions provided by existing `fxts` to be used in a method chaining.
 *  Not all functions are provided as methods and can be connected through `chain` if necessary.
 *
 *  see {@link https://fxts.dev/docs/method-chaining | guide}
 *
 * @example
 * ```ts
 * const syncArr1 = fx([1, 2, 3, 4])
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 *
 * // If you want to use another function that is not provided for the method, use `chain`.
 * const syncArr2 = fx([1, 2, 3, 4])
 *   .chain(append(5))
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14, 15]
 *
 * const asyncArr1 = await fx([1, 2, 3, 4])
 *   .toAsync()
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 *
 * const asyncArr2 = await fx(toAsync([1, 2, 3, 4]))
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 * ```
 */
function fx(a) {
    if (isAsyncIterable(a)) {
        return new FxAsyncIterable(a);
    }
    else if (isIterable(a)) {
        return new FxIterable(a);
    }
    throw new TypeError(`'fx' must be type of Iterable or AsyncIterable`);
}
export default fx;
//# sourceMappingURL=fx.js.map