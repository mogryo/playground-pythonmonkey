{"version":3,"file":"reduceLazy.js","sourceRoot":"","sources":["../../src/reduceLazy.ts"],"names":[],"mappings":"AAAA,OAAO,MAAM,MAAM,UAAU,CAAC;AA8F9B,SAAS,UAAU,CACjB,CAAqC,EACrC,IAAU;IAEV,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,OAAO,CAAC,QAAoD,EAAE,EAAE,CAC9D,MAAM,CAAC,CAAC,EAAE,QAAe,CAAC,CAAC;KAC9B;IACD,OAAO,CAAC,QAAoD,EAAE,EAAE,CAC9D,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,QAAe,CAAC,CAAC;AACrC,CAAC;AAED,eAAe,UAAU,CAAC","sourcesContent":["import reduce from \"./reduce\";\nimport type IterableInfer from \"./types/IterableInfer\";\nimport type { AsyncReducer, SyncReducer } from \"./types/Reducer\";\nimport type ReturnValueType from \"./types/ReturnValueType\";\n\ntype InferCarrier<T> = T extends AsyncIterable<infer R>\n  ? AsyncIterable<R>\n  : T extends Iterable<unknown>\n  ? T\n  : never;\n\n// DO NOT change the order of signatures prematurely.\n// See `reduceLazy.test.ts` for the reason\n\n/**\n * High order functional version of `reduce`, which behaves identical to it.\n *\n * @param f Reducer function `(acc, value) => acc`. It can be both synchronous and asynchronous.\n * @param seed Initial value. Note that if the type of `acc` and `value` differ, `seed` must be given.\n *\n * @example\n * Type must be provided for stand alone call.\n *\n * ```ts\n * const reduce = reduceLazy((a: number, b: number) => a + b, 5)\n *\n * reduce([1, 2, 3]) // number\n * reduce(toAsync([1, 2, 3])) // Promise<number>\n * ```\n *\n * Fit perfectly with `pipe`\n *\n * ```ts\n * pipe(\n *   [1, 2, 3, 4],\n *   reduceLazy((a, b) => a + b, 5)\n * ); // 15\n * ```\n *\n * You can use asynchronous callback\n *\n * ```ts\n * await pipe(\n *   [1, 2, 3, 4],\n *   reduceLazy(async (a, b) => a + b, 5)\n * ); // 15\n * ```\n *\n * `AsyncIterable` doesn't matter.\n *\n * ```ts\n * await pipe(\n *   [1, 2, 3, 4],\n *   toAsync,\n *   reduceLazy((a, b) => a + b, 5)\n * ); // 15\n * ```\n */\nfunction reduceLazy<T extends Iterable<unknown> | AsyncIterable<unknown>, Acc>(\n  f: SyncReducer<Acc, IterableInfer<T>> | AsyncReducer<Acc, IterableInfer<T>>,\n  seed: Acc,\n): (iterable: InferCarrier<T>) => ReturnValueType<T, Acc>;\n\nfunction reduceLazy<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f:\n    | AsyncReducer<IterableInfer<T>, IterableInfer<T>>\n    | SyncReducer<IterableInfer<T>, IterableInfer<T>>,\n  seed?: IterableInfer<T>,\n): (iterable: InferCarrier<T>) => ReturnValueType<T, IterableInfer<T>>;\n\nfunction reduceLazy<T, Acc>(\n  f: SyncReducer<Acc, T>,\n  seed: Acc,\n): <C extends Iterable<T> | AsyncIterable<T>>(\n  iterable: C,\n) => ReturnValueType<C, Acc>;\n\nfunction reduceLazy<T>(\n  f: SyncReducer<T, T>,\n  seed?: T,\n): <C extends Iterable<T> | AsyncIterable<T>>(\n  iterable: C,\n) => ReturnValueType<C>;\n\nfunction reduceLazy<T, Acc>(\n  f: AsyncReducer<Acc, T>,\n  seed: Acc,\n): (iterable: Iterable<T> | AsyncIterable<T>) => Promise<Acc>;\n\nfunction reduceLazy<T>(\n  f: AsyncReducer<T, T>,\n  seed?: T,\n): (iterable: Iterable<T> | AsyncIterable<T>) => Promise<T>;\n\nfunction reduceLazy<T extends Iterable<unknown> | AsyncIterable<unknown>, Acc>(\n  f: SyncReducer<Acc, IterableInfer<T>>,\n  seed?: Acc,\n) {\n  if (seed === undefined) {\n    return (iterable: Iterable<unknown> | AsyncIterable<unknown>) =>\n      reduce(f, iterable as any);\n  }\n  return (iterable: Iterable<unknown> | AsyncIterable<unknown>) =>\n    reduce(f, seed, iterable as any);\n}\n\nexport default reduceLazy;\n"]}