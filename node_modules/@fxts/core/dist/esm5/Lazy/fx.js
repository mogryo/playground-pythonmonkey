import { __asyncValues, __awaiter, __generator } from "tslib";
import { isAsyncIterable, isIterable } from "../_internal/utils.js";
import consume from "../consume.js";
import each from "../each.js";
import every from "../every.js";
import find from "../find.js";
import findIndex from "../findIndex.js";
import groupBy from "../groupBy.js";
import indexBy from "../indexBy.js";
import isUndefined from "../isUndefined.js";
import join from "../join.js";
import reduce from "../reduce.js";
import some from "../some.js";
import concurrent from "./concurrent.js";
import drop from "./drop.js";
import filter from "./filter.js";
import flat from "./flat.js";
import flatMap from "./flatMap.js";
import map from "./map.js";
import peek from "./peek.js";
import reject from "./reject.js";
import slice from "./slice.js";
import take from "./take.js";
import takeUntil from "./takeUntil.js";
import takeWhile from "./takeWhile.js";
import toAsync from "./toAsync.js";
var FxAsyncIterable = /** @class */ (function () {
    function FxAsyncIterable(asyncIterable) {
        this.asyncIterable = asyncIterable;
    }
    FxAsyncIterable.prototype[Symbol.asyncIterator] = function () {
        return this.asyncIterable[Symbol.asyncIterator]();
    };
    /**
     * Returns AsyncIterable of values by running each applying `f`.
     *
     * see {@link https://fxts.dev/docs/map | map}
     */
    FxAsyncIterable.prototype.map = function (f) {
        return new FxAsyncIterable(map(f, this.asyncIterable));
    };
    /**
     * Returns flattened AsyncIterable of values by running each element
     * flattening the mapped results.
     *
     * see {@link https://fxts.dev/docs/flatMap | flatMap}
     */
    FxAsyncIterable.prototype.flatMap = function (f) {
        return new FxAsyncIterable(flatMap(f, this.asyncIterable));
    };
    /**
     * Returns flattened AsyncIterable.
     * If first argument is number, more perform flatten
     *
     * @example
     * ```
     * await fx([[1],[[2]]])
     *   .toAsync()
     *   .flat(2).toArray(); // [1,2]
     * ```
     *
     * see {@link https://fxts.dev/docs/flat | flat}
     */
    FxAsyncIterable.prototype.flat = function (depth) {
        return new FxAsyncIterable(flat(this.asyncIterable, depth));
    };
    /**
     * Return AsyncIterable of all elements `f` returns truthy for
     *
     * see {@link https://fxts.dev/docs/filter | filter}
     */
    FxAsyncIterable.prototype.filter = function (f) {
        return new FxAsyncIterable(filter(f, this.asyncIterable));
    };
    /**
     * The opposite of filter method
     * AsyncIterable of all elements `f` returns falsy for
     *
     * see {@link https://fxts.dev/docs/reject | reject}
     */
    FxAsyncIterable.prototype.reject = function (f) {
        return new FxAsyncIterable(reject(f, this.asyncIterable));
    };
    /**
     * Returns AsyncIterable that taken the first argument `l` values from asyncIterable
     *
     * see {@link https://fxts.dev/docs/take | take}
     */
    FxAsyncIterable.prototype.take = function (n) {
        return new FxAsyncIterable(take(n, this.asyncIterable));
    };
    /**
     * Returns AsyncIterable that taken values until truthy when given `f` is applied.
     *
     * see {@link https://fxts.dev/docs/takeUntil | takeUntil}
     */
    FxAsyncIterable.prototype.takeUntil = function (f) {
        return new FxAsyncIterable(takeUntil(f, this.asyncIterable));
    };
    /**
     * Returns AsyncIterable that taken values as long as each value satisfies the give `f`.
     *
     * see {@link https://fxts.dev/docs/takeWhile | takeWhile}
     */
    FxAsyncIterable.prototype.takeWhile = function (f) {
        return new FxAsyncIterable(takeWhile(f, this.asyncIterable));
    };
    /**
     * Iterate over an input list,
     * calling a provided `f` for each element in the AsyncIterable.
     *
     * see {@link https://fxts.dev/docs/peek | peek}
     */
    FxAsyncIterable.prototype.peek = function (f) {
        return new FxAsyncIterable(peek(f, this.asyncIterable));
    };
    /**
     * Returns all but the first `length` elements of the given asyncIterable.
     *
     * see {@link https://fxts.dev/docs/drop | drop}
     */
    FxAsyncIterable.prototype.drop = function (length) {
        return new FxAsyncIterable(drop(length, this.asyncIterable));
    };
    /**
     * Returns AsyncIterable of the given elements from startIndex(inclusive) to endIndex(exclusive).
     *
     * see {@link https://fxts.dev/docs/slice | slice}
     */
    FxAsyncIterable.prototype.slice = function (start, end) {
        return isUndefined(end)
            ? new FxAsyncIterable(slice(start, this.asyncIterable))
            : new FxAsyncIterable(slice(start, end, this.asyncIterable));
    };
    /**
     *
     * `chain` allows you to use functions that are not provided in method chaining.
     * The functions available for the `chain` argument return an iterable.
     *
     * @example
     * ```
     * await fx(toAsync(range(1, 4)))
     *   .chain(append(4))
     *   .chain(append(5))
     *   .toArray(); // [1, 2, 3, 4, 5]
     * ```
     */
    FxAsyncIterable.prototype.chain = function (f) {
        return new FxAsyncIterable(f(this.asyncIterable));
    };
    /**
     * Concurrent is used to balance the load of multiple asynchronous requests.
     * The first argument receives a number that controls the number of loads, and the second argument is an AsyncIterable.
     *
     * see {@link https://fxts.dev/docs/concurrent | concurrent}
     */
    FxAsyncIterable.prototype.concurrent = function (length) {
        return new FxAsyncIterable(concurrent(length, this.asyncIterable));
    };
    FxAsyncIterable.prototype.consume = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, consume(this.asyncIterable)];
            });
        });
    };
    /**
     * Splits AsyncIterable into sets, grouped by the result of running each value through `f`.
     *
     * see {@link https://fxts.dev/docs/groupBy | groupBy}
     */
    FxAsyncIterable.prototype.groupBy = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, groupBy(f, this.asyncIterable)];
            });
        });
    };
    /**
     * Given `f` that generates a key,
     * turns a list of objects into an object indexing the objects by the given key.
     * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.
     *
     * see {@link https://fxts.dev/docs/indexBy | indexBy}
     */
    FxAsyncIterable.prototype.indexBy = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, indexBy(f, this.asyncIterable)];
            });
        });
    };
    /**
     * Returns true if any of the values in AsyncIterable pass `f` truth test
     *
     * see {@link https://fxts.dev/docs/some | some}
     */
    FxAsyncIterable.prototype.some = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, some(f, this.asyncIterable)];
            });
        });
    };
    /**
     * Returns true if all of the values in AsyncIterable pass the `f` truth test.
     *
     * see {@link https://fxts.dev/docs/every | every}
     */
    FxAsyncIterable.prototype.every = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, every(f, this.asyncIterable)];
            });
        });
    };
    /**
     * Returns all elements in the given iterable into a string separated by separator.
     *
     * see {@link https://fxts.dev/docs/join | join}
     */
    FxAsyncIterable.prototype.join = function (sep) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, join(sep, this.asyncIterable)];
            });
        });
    };
    /**
     * Looks through each value in AsyncIterable, returning the first one that passes a truth test `f`,
     * or `undefined` if no value passes the test.
     *
     * see {@link https://fxts.dev/docs/find | find}
     */
    FxAsyncIterable.prototype.find = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, find(f, this.asyncIterable)];
            });
        });
    };
    /**
     * Returns the index of the first element of AsyncIterable which matches f, or -1 if no element matches.
     *
     * see {@link https://fxts.dev/docs/findIndex | findIndex}
     */
    FxAsyncIterable.prototype.findIndex = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, findIndex(f, this.asyncIterable)];
            });
        });
    };
    /**
     * Also known as foldl, this method boils down a list of values into a single value.
     *
     * see {@link https://fxts.dev/docs/reduce | reduce}
     */
    FxAsyncIterable.prototype.reduce = function (f, seed) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, isUndefined(seed)
                        ? reduce(f, this.asyncIterable)
                        : reduce(f, seed, this.asyncIterable)];
            });
        });
    };
    /**
     * Iterates over AsyncIterable, applying each in turn to `f`.
     *
     * see {@link https://fxts.dev/docs/each | each}
     */
    FxAsyncIterable.prototype.each = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, each(f, this.asyncIterable)];
            });
        });
    };
    /**
     * Takes item from AsyncIterable and returns an array.
     *
     * see {@link https://fxts.dev/docs/toArray | toArray}
     */
    FxAsyncIterable.prototype.toArray = function () {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var array, _d, _e, _f, a, e_1_1;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        array = [];
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 6, 7, 12]);
                        _d = true, _e = __asyncValues(this.asyncIterable);
                        _g.label = 2;
                    case 2: return [4 /*yield*/, _e.next()];
                    case 3:
                        if (!(_f = _g.sent(), _a = _f.done, !_a)) return [3 /*break*/, 5];
                        _c = _f.value;
                        _d = false;
                        a = _c;
                        array.push(a);
                        _g.label = 4;
                    case 4:
                        _d = true;
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_1_1 = _g.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _g.trys.push([7, , 10, 11]);
                        if (!(!_d && !_a && (_b = _e.return))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _b.call(_e)];
                    case 8:
                        _g.sent();
                        _g.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12: return [2 /*return*/, array];
                }
            });
        });
    };
    return FxAsyncIterable;
}());
var FxIterable = /** @class */ (function () {
    function FxIterable(iterable) {
        this.iterable = iterable;
    }
    FxIterable.prototype[Symbol.iterator] = function () {
        return this.iterable[Symbol.iterator]();
    };
    /**
     * Returns Iterable of values by running each applying `f`.
     *
     * see {@link https://fxts.dev/docs/map | map}
     */
    FxIterable.prototype.map = function (f) {
        return new FxIterable(map(f, this.iterable));
    };
    /**
     * Returns flattened Iterable of values by running each element
     * flattening the mapped results.
     *
     * see {@link https://fxts.dev/docs/flatMap | flatMap}
     */
    FxIterable.prototype.flatMap = function (f) {
        return new FxIterable(flatMap(f, this.iterable));
    };
    /**
     * Returns flattened Iterable.
     * If first argument is number, more perform flatten
     *
     * @example
     * `fx([[1],[[2]]]).flat(2).toArray(); // [1,2]`
     *
     * see {@link https://fxts.dev/docs/flat | flat}
     */
    FxIterable.prototype.flat = function (depth) {
        var res = flat(this.iterable, depth);
        return new FxIterable(res);
    };
    /**
     * Return Iterable of all elements `f` returns truthy for
     *
     * see {@link https://fxts.dev/docs/filter | filter}
     */
    FxIterable.prototype.filter = function (f) {
        return new FxIterable(filter(f, this.iterable));
    };
    /**
     * The opposite of filter method
     * Iterable of all elements `f` returns falsy for
     *
     * see {@link https://fxts.dev/docs/reject | reject}
     */
    FxIterable.prototype.reject = function (f) {
        return new FxIterable(reject(f, this.iterable));
    };
    /**
     * Returns Iterable that taken the first argument `l` values from iterable
     *
     * see {@link https://fxts.dev/docs/take | take}
     */
    FxIterable.prototype.take = function (n) {
        return new FxIterable(take(n, this.iterable));
    };
    /**
     * Returns Iterable that taken values until truthy when given `f` is applied.
     *
     * see {@link https://fxts.dev/docs/takeUntil | takeUntil}
     */
    FxIterable.prototype.takeUntil = function (f) {
        return new FxIterable(takeUntil(f, this.iterable));
    };
    /**
     * Returns Iterable that taken values as long as each value satisfies the give `f`.
     *
     * see {@link https://fxts.dev/docs/takeWhile | takeWhile}
     */
    FxIterable.prototype.takeWhile = function (f) {
        return new FxIterable(takeWhile(f, this.iterable));
    };
    /**
     * Iterate over an input list,
     * calling a provided `f` for each element in the Iterable.
     *
     * see {@link https://fxts.dev/docs/peek | peek}
     */
    FxIterable.prototype.peek = function (f) {
        return new FxIterable(peek(f, this.iterable));
    };
    /**
     * Returns all but the first `length` elements of the given iterable.
     *
     * see {@link https://fxts.dev/docs/drop | drop}
     */
    FxIterable.prototype.drop = function (length) {
        return new FxIterable(drop(length, this.iterable));
    };
    /**
     * Returns Iterable of the given elements from startIndex(inclusive) to endIndex(exclusive).
     *
     * see {@link https://fxts.dev/docs/slice | slice}
     */
    FxIterable.prototype.slice = function (start, end) {
        return isUndefined(end)
            ? new FxIterable(slice(start, this.iterable))
            : new FxIterable(slice(start, end, this.iterable));
    };
    /**
     *
     * `chain` allows you to use functions that are not provided in method chaining.
     * The functions available for the `chain` argument return an asyncIterable.
     *
     * @example
     * ```
     * fx(range(1, 4))
     *   .chain(append(4))
     *   .chain(append(5))
     *   .toArray(); // [1, 2, 3, 4, 5]
     * ```
     */
    FxIterable.prototype.chain = function (f) {
        return new FxIterable(f(this.iterable));
    };
    /**
     * Returns AsyncIterable, `toAsync` used when you want to handle Promise values inside Iterable.
     *
     * see {@link https://fxts.dev/docs/toAsync | toAsync}
     */
    FxIterable.prototype.toAsync = function () {
        return new FxAsyncIterable(toAsync(this.iterable));
    };
    /**
     * Splits Iterable into sets, grouped by the result of running each value through `f`.
     *
     * see {@link https://fxts.dev/docs/groupBy | groupBy}
     */
    FxIterable.prototype.groupBy = function (f) {
        return groupBy(f, this.iterable);
    };
    /**
     * Given `f` that generates a key,
     * turns a list of objects into an object indexing the objects by the given key.
     * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.
     *
     * see {@link https://fxts.dev/docs/indexBy | indexBy}
     */
    FxIterable.prototype.indexBy = function (f) {
        return indexBy(f, this.iterable);
    };
    /**
     * Returns true if any of the values in AsyncIterable pass `f` truth test
     *
     * see {@link https://fxts.dev/docs/some | some}
     */
    FxIterable.prototype.some = function (f) {
        return some(f, this.iterable);
    };
    /**
     * Returns true if all of the values in AsyncIterable pass the `f` truth test.
     *
     * see {@link https://fxts.dev/docs/every | every}
     */
    FxIterable.prototype.every = function (f) {
        return every(f, this.iterable);
    };
    /**
     * Returns all elements in the given iterable into a string separated by separator.
     *
     * see {@link https://fxts.dev/docs/join | join}
     */
    FxIterable.prototype.join = function (sep) {
        return join(sep, this.iterable);
    };
    /**
     * Looks through each value in AsyncIterable, returning the first one that passes a truth test `f`,
     * or `undefined` if no value passes the test.
     *
     * see {@link https://fxts.dev/docs/find | find}
     */
    FxIterable.prototype.find = function (f) {
        return find(f, this.iterable);
    };
    /**
     * Returns the index of the first element of AsyncIterable which matches f, or -1 if no element matches.
     *
     * see {@link https://fxts.dev/docs/findIndex | findIndex}
     */
    FxIterable.prototype.findIndex = function (f) {
        return findIndex(f, this.iterable);
    };
    /**
     * Also known as foldl, this method boils down a list of values into a single value.
     *
     * see {@link https://fxts.dev/docs/reduce | reduce}
     */
    FxIterable.prototype.reduce = function (f, seed) {
        return isUndefined(seed)
            ? reduce(f, this.iterable)
            : reduce(f, seed, this.iterable);
    };
    /**
     * Iterates over Iterable, applying each in turn to `f`.
     *
     * see {@link https://fxts.dev/docs/each | each}
     */
    FxIterable.prototype.each = function (f) {
        return each(f, this.iterable);
    };
    /**
     * Takes item from Iterable and returns an array.
     *
     * see {@link https://fxts.dev/docs/toArray | toArray}
     */
    FxIterable.prototype.toArray = function () {
        return Array.from(this.iterable);
    };
    FxIterable.prototype.toIterator = function () {
        return Array.from(this.iterable);
    };
    return FxIterable;
}());
export { FxIterable };
/**
 * `fx` allows functions provided by existing `fxts` to be used in a method chaining.
 *  Not all functions are provided as methods and can be connected through `chain` if necessary.
 *
 *  see {@link https://fxts.dev/docs/method-chaining | guide}
 *
 * @example
 * ```ts
 * const syncArr1 = fx([1, 2, 3, 4])
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 *
 * // If you want to use another function that is not provided for the method, use `chain`.
 * const syncArr2 = fx([1, 2, 3, 4])
 *   .chain(append(5))
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14, 15]
 *
 * const asyncArr1 = await fx([1, 2, 3, 4])
 *   .toAsync()
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 *
 * const asyncArr2 = await fx(toAsync([1, 2, 3, 4]))
 *   .map((a) => a + 10)
 *   .toArray(); // [11, 12, 13, 14]
 * ```
 */
function fx(a) {
    if (isAsyncIterable(a)) {
        return new FxAsyncIterable(a);
    }
    else if (isIterable(a)) {
        return new FxIterable(a);
    }
    throw new TypeError("'fx' must be type of Iterable or AsyncIterable");
}
export default fx;
//# sourceMappingURL=fx.js.map